{"version":3,"sources":["../src/index.js"],"names":["isJSON","p","test","Context","constructor","snapshotsDir","setDir","dir","save","path","snapshot","space","ws","prompt","console","log","colors","promise","answer","promptAndSave","actual","err","Error","res","read","trim","cb","json","expected","code","s","e","erte"],"mappings":"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","sourcesContent":["import { resolve } from 'path'\nimport erte from 'erte'\nimport { equal } from 'assert'\nimport reloquent from 'reloquent'\nimport { inspect } from 'util'\nimport { deepEqual } from 'assert-diff'\nimport { read, write, createWritable, ensurePath, writeJSON, readJSON } from 'wrote'\nimport erotic from 'erotic'\n\nconst isJSON = p => /\\.json$/.test(p)\n\n/**\n * SnapshotContext allows to match the test result against a snapshot.\n */\nexport default class Context {\n  constructor() {\n    this.snapshotsDir = ''\n  }\n  /**\n   * Set the directory to save snapshots in.\n   * @param {string} dir The directory.\n   */\n  setDir(dir) {\n    this.snapshotsDir = dir\n  }\n  async save(path, snapshot) {\n    const p = resolve(this.snapshotsDir, path)\n    await ensurePath(p)\n    if (isJSON(p)) {\n      await writeJSON(p, snapshot, { space: 2 })\n    } else {\n      const ws = await createWritable(p)\n      await write(ws, snapshot)\n    }\n  }\n  async prompt(snapshot) {\n    if (typeof snapshot == 'string') {\n      console.log(snapshot) // eslint-disable-line no-console\n    } else {\n      console.log(inspect(snapshot, { colors: true })) // eslint-disable-line\n    }\n    const { promise } = reloquent('save snapshot? ')\n    const answer = await promise\n    return answer == 'y'\n  }\n  async promptAndSave(path,\n    actual,\n    err = new Error('could not test missing snapshot')\n  ) {\n    if (!actual) throw new Error('give snapshot to save')\n    const res = await this.prompt(actual)\n    if (res) {\n      await this.save(path, actual)\n    } else {\n      throw err\n    }\n  }\n  async read(path) {\n    const p = resolve(this.snapshotsDir, path)\n    if (isJSON(p)) {\n      const snapshot = await readJSON(p)\n      return snapshot\n    } else {\n      const snapshot = await read(p)\n      return snapshot.trim()\n    }\n  }\n  /**\n   * Test the snapshot by reading the file and matching it against the given actual value. If filename ends with .json, the data will be serialised as a JSON, and then parsed back and deep-equal will be performed. Otherwise, string comparison is made with red/green highlighting. If no file exists, a prompt will be shown to save a snapshot. Answer with **y** to accept the snapshot and pass the test. There's no update possibility which means files must be deleted by hand and new snapshots taken.\n   * @param {string} path Path to the file\n   * @param {string} actual Expected result\n   */\n  async test(path, actual) {\n    if (!actual) throw new Error('pass the actual value')\n    const cb = erotic(true)\n    const json = isJSON(path)\n    let expected\n    try {\n      expected = await this.read(path)\n      if (json) {\n        deepEqual(actual, expected)\n      } else {\n        equal(actual, expected)\n      }\n    } catch (err) {\n      if (err.code == 'ENOENT') {\n        await this.promptAndSave(path, actual)\n        return\n      }\n      if (!json) {\n        const s = erte(expected, actual)\n        console.log(s) // eslint-disable-line no-console\n        const e = cb('The string didn\\'t match the snapshot.')\n        e.erte = s\n        throw e\n      }\n      const e = cb(err)\n      throw e\n    }\n  }\n}\n"],"file":"index.js"}